### 予想

各要素へのアクセスが等しく速くなるので、乗算の計算全体は型付き配列の方が定数倍速くなる。

### 実験結果

UInt16Array、Float64Array、Float32Arrayで実験し、それぞれArrayと比較した結果を後に示す。
(UInt16Arrayとの比較では0、1、２がランダムに割り振られた配列で実験を行った)

|           要素数            | UInt16Array | Array |
| :-------------------------: | :---------: | :---: |
|   [N, K, M] = [5, 10, 15]   |    0.100    | 0.126 |
|  [N, K, M] = [10, 20, 30]   |    0.704    | 0.813 |
|  [N, K, M] = [20, 40, 60]   |    4.89     | 5.87  |
| [N, K, M] = [50, 100, 150]  |    65.3     | 74.2  |
| [N, K, M] = [100, 200, 300] |     541     |  618  |

|           要素数            | Float64Array | Float32Array | Array  |
| :-------------------------: | :----------: | :----------: | :----: |
|   [N, K, M] = [5, 10, 15]   |    0.0854    |    0.0931    | 0.0974 |
|  [N, K, M] = [10, 20, 30]   |    0.529     |    0.589     | 0.641  |
|  [N, K, M] = [20, 40, 60]   |     3.77     |     4.03     |  4.36  |
| [N, K, M] = [50, 100, 150]  |     55.6     |     58.7     |  57.0  |
| [N, K, M] = [100, 200, 300] |     492      |     493      |  492   |

### 考察

UInt16ArrayとArrayの比較では要素数が増えてもUInt16Array側の計算が1.1~1.2倍の速さとなる一方、
Float64Array、Float32Array、Arrayの比較では、要素数が増えると計算時間に差が生まれなくなった。
Floatの場合は浮動小数計算がボトルネックとなっている？
