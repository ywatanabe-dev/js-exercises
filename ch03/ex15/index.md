### 実行結果の予想

0から9を順に出力した後、定義されていない変数を呼び出そうとして失敗する。

### 実行結果

予想と同じ。以下のような結果が出力された。

```
0
1
2
3
4
5
6
7
8
9
(略)
ReferenceError: i is not defined
```

### 上記の結果になった考察

`let`による宣言を使うと、宣言したブロックに変数のスコープを限定することができる。
よって、

- for文先頭で宣言された`i`はfor文内のみで有効
- for文の中で定義された関数内で宣言された`i`は、for文先頭の`i`の宣言を上書きし、その関数内でのみ有効

という挙動になり、for文の外で`i`は宣言されていない扱いとなる。

その結果、一個目のconsole.log()ではfor文のスコープの`i`の値を順に出力し、二個目のconsole.log()で実行時エラーとなる。

### `let`を`var`に変えた場合

```javascript
for (var i = 0; i < 10; i++) {
  (function () {
    var i = 100;
  })();
  console.log(i);
}
console.log(i);
```

実行結果は以下の通り。

```
0
1
2
3
4
5
6
7
8
9
10
```

`var`による宣言は関数スコープ内で有効であり、関数外で宣言された場合はグローバルスコープで有効となる。
今回の実装の場合は、for文の先頭での`i`の宣言がグローバルスコープで有効となる。
また、関数内の`i`の宣言は関数のスコープでのみ有効であり、関数の外側の`i`とは別の扱いになる。
よって、一個目・二個目のconsole.log()はともにグローバルスコープの`i`の値の変化を順に表示する挙動となる。

### `let`を消した場合(非厳格モード)

```javascript
for (i = 0; i < 10; i++) {
  (function () {
    i = 100;
  })();
  console.log(i);
}
console.log(i);
```

実行結果は以下の通り。

```
100
101
```

厳格モードでない場合に、同じスコープに同名で宣言されている変数がない時は、
グローバルスコープで宣言されたとみなされる。

```javascript
// 上記のコードの後で実行した時の結果
Object.hasOwn(globalThis, "i"); // => true
```

関数内のスコープでも`let`や`var`による宣言がないため、その後の処理も全てグローバルスコープの`i`が参照される。
その結果、forループの一個目に`i`に100が代入された後に1度目のconsole.log()で値が表示され、
`i++`で101になり、ループを抜けた後に二個目のconsole.log()で値が表示される。
